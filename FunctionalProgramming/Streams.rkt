;(define (delay expr)
;  (lambda() expr)
;  )
;(define (print-stream stream)
;  (if (empty-stream? stream) (display `end)
;      (begin
;        (display " ")
;        (princ (head stream))
;        (newline)
;        (newline)
;        (print-stream (tail stream))
;      )
;  )
;)
;define basic functions
(define (f x)
  (* x 2)
  )
(define (g x)
  (+ x 1)
  )
(define empty-stream? null?)
(define (cons-stream a b)
  (cons a (delay b))
  )
(define (head x)
  (car x)
  )
(define (tail x)
  (force (cdr x))
  )
(define (sprint n stream)
  (cond ((= n 0) '())
        (else (begin (display (head stream))
                     (display " ")
                     ;(newline)
                     (sprint (- n 1) (tail stream)))
        )
  )
)

;simple stream of a
(define (aces a)
  (cons-stream a (aces a))
  )
;(define ones
;  (cons-stream 1 ones)
;  )

;function to merge to add and merge two streams
(define (add-stream s1 s2)
  (cond((empty-stream? s1) s2)
       ((empty-stream? s2) s1)
       (else (cons-stream (+ (head s1) (head s2)) 
                          (add-stream (tail s1) (tail s2))) 
        )
  )
)

;stream-mapping function
(define (map-stream f s)
  (if (empty-stream? s) s
      (cons-stream (f (head s)) (map-stream f (tail s)))
      )
  )
;(define (repeated f a)
;  (cons-stream a (map-stream f (tail (repeated f a))))
;)

;recursive nested function stream
(define (repeated f a)
  (cons-stream a (repeated f (f a)))
  )

;merge two streams
(define (mixstream s1 s2)
   (cons-stream (head s1)(cons-stream (head s2)
                          (mixstream (tail s1) (tail s2)))
   )
)

;f g f(a) g(a) f(f(a)) g(g(a))...
(define (funcstream f g a)
  (define s1 (repeated f (f a)))
  (define s2 (repeated g (g a)))
  (cons-stream a (mixstream s1 s2))
)

;x/2(even) 3*x+1/2(odd) stream
(define (stream-nat a)
  (define (helper x)
    (if(even? x) (/ x 2)
       (/ (+ (* 3 x) 1) 2)
       )
    )
  (cons-stream a (stream-nat (helper a)))
  )

;swap elements
(define (swap_car! l1 l2)
  (begin (set_car! l1 (car l2))
         (set_car! l2 (car l1))
  )
)

;get n-th sublist of given list
(define (nth-sublist l n)
  (cond((null? l) l)
       ((= n 1) l)
       (else (nth-sublist (cdr l) (- n 1)))
  )
)

;swap adjacent elements in list for all the list
(define (swap-list l)
  (define (helper list)   
         (cond((null? list) list)
              ((null? (cdr list)) list)
              (else
                 (let ((first (car list))
                       (second (cadr list)))
                     (begin (set-car! list second)
                            (set-car! (cdr list) first)
                            (helper (cddr list)))
                  )
               )
         )
  )(helper l)
)

(define l (list 1 2 3 4 5))

;count divisors of a number
(define (count_div num)
  (define (helper iter res)
    (cond((> iter num) res)
         ((= (remainder num iter) 0) (helper (+ iter 1)(+ res 1)))
         (else (helper (+ iter 1) res))
    )
  )(helper 1 0)
)

;prime: if a number has two divisors - 1 and itself, it's a prime
(define (prime? num)
  (= (count_div num) 2)
  )

;define stream [1..n]
(define (integers-from n)
  (cons-stream n (integers-from (+ 1 n)))
  )
;(define naturals (cons-stream 1 (add-stream ones naturals)))

;convert decimal number to binary
(define (convert-binary num)
  (define (helper n list)
    (cond((< num 2) (cons `1 list))
         ((even? num) (helper (quotient num 2) (cons `0 list)))
         (else (helper (quotient num 2) (cons `1 list)))
    )
  )(helper num `())
)

;define stream with first n primes
(define (primestr n)
  (define (helper x)
    (if(prime? x)(cons-stream x (cons-stream x (helper (+ x 1))))
       (cons-stream x (helper (+ x 1)))
    )
  )
  (cons-stream n (helper (+ n 1)))
)

;(define (str a b)
;  (define (helper iter a b)
;    (let ((x a))
;      (if(even? iter) (cons-stream a (helper (+ iter 1) b (+ a b)))
;         (cons-stream a (helper (+ iter 1) b x))
;      )
;    )
;  )(helper 0 a b)
;)

(define (accumulate comb null_value l)
  (if(null? l) `()
     (comb (car l)
           (accumulate comb null_value (cdr l)))
     )
  )
;(define (filter pred? l)
;  (cond((null? l) `())
;       ((pred? (car l)) (cons(car l)(filter pred? (cdr l))))
;       (else (filter pred? (cdr l)))
;    )
;  )
;(define (map f l)
;  (if(null? l)`()
;     (cons (f (car l)) (map f (cdr l)))
;     )
;  )

;determine is number is composed by power of 2
(define (pow2? num)
  (cond((= num 1) #t)
       ((= (remainder num 2) 0) (pow2? (/ num 2)))
       (else #f)
    )
  )

(define (countdeg num)
  (define (helper n deg)
    (if(= n 1) deg
       (helper (/ n 2)(+ deg 1))
     )
    )(helper num 0)
  )
(define l `(1 2 3))
(define (cycle-list l)
    (if(null? l) (cycle-list l)
       (cons-stream (car l) (cycle-list (cdr l)))
       )
  )